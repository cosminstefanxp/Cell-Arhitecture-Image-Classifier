#===============================================================================
# ASC - Tema 4 -  Feature reduction for pattern recognition
# Stefan-Dobrin Cosmin
# 331CA
#===============================================================================

1. Cerinta
	Realizarea, pe arhitectura Cell, a unui clasificator care sa reuseasca sa deosebeasca doua tipuri de animale.

2. Utilizare
	Executabilul obtinut in urma rularii Makefile-ului, pentru ppu se numeste tema4, iar pentru spu se numeste tema4_spu.
	Parametrii de rulare sunt cei din cerinta de la tema3, putin modificati: tema4  {clasa_1} {clasa_2} {nr_img_training} -c {folder_clasificare} {nr_img_clasif}
	Parametrii de rulare sunt verificati la executie si sunt afisate erori in cazul aparitiei unor probleme. De asemenea, citirea imaginilor a fost implementata intr-un mod care permite introducerea de nume complexe pentru imagini, fiind pastrat doar numele ultimului folder ca nume al imaginii. Exemplu: ../images/elefant -> imaginile au numele de forma ../images/elefant/elefant_%d.pgm.
	
	Makefile-ul are pus la dispozitie un target run care ruleaza tema cu parametrii: ./tema4 images/tigru images/elefant 8 -c images/test 8	
	Makefile-ul pus la dispozitie realizeaza compilarea celor 2 executabile. Programele are numeroase linii de debug care pot fi activate decomentand linia: CFLAGS := -DDEBUG_ din ambele makefile-uri. Comentariile folosesc conceptul de logging si au diferinte nivele de prioritate. In cazul in care nivelul de prioritate nu este setat prin -DLOG_LEVEL=LOG_xxxxx, acesta are o valoare default definita in util.h.

3. Implementare
	Tema a fost implementata in C++ si testata pe sistemul cell din cadrul grid-ul Politehnicii.
	Asa cum am mentionat mai sus, ambele programe (ppu si spu) au numeroase linii ce sunt afisate la definirea simbolului DEBUG_ si cu LOG_LEVEL corespunzator.
	De asemenea, in cadrul programului am folosit numeroase asertiuni pentru a verificare diferite consistente ale datelor sau conditii speciale ce ar trebui sa depinda de exterior. In cadrul testelor efectuate de mine, versiunea curenta nu declanseaza nici o asertiune. Restrictiile aparute sunt cele care au fost permise pe forumul de discutii.
	Codul programului a fost scris cat mai general, incercand sa iau in considerare cat mai multe cazuri ce pot aparea. Sper ca am acoperit o cat mai mare parte a posibilitatilor.
	Ca limitari, ar trebui sa adaug urmatoarele (restrictii care au fost permise in enuntul temei sau in cadrul discutiilor de pe forum): M<=64 (am considerat ca o matrice M de float-uri se poate transmite intr-un singur transfer DMA), M%4==0 (practic atat W cat si H sa fie pare), astfel incat adresa unei noi linii din matricele de M*M de float-uri sa fie multiplu de 16.   
	
	Tema contine urmatoarele surse:
		o tema4.c - sursa principala pentru ppu
		o tema4.h - header comun folosit si de spu, in care sunt definite structurile/valorile constante comune pt spu si ppu 
		o imglib.c / imglib.h - pentru lucrul cu imagini pgm
		o util.h - pentru codul de debug
		o spu/tema4_spu.c -sursa principala pentru spu

3.1 Aspecte importante ale implementarii
	-principiul principal de comunicare intre PPU - SPU-uri:
		o PPU-ul trimite prin mailbox adresa unei structuri task_t, ce contine toate informatiile necesare pentru task-ul curent
		o SPU-ul obtine prin DMA acea structura si folosind datele din ea (eventual cu alte accese la memoria principala - accese DMA sau folosind software managed cache), rezolva task-ul
		o SPU-ul trimite prin outbox-interrupt-ul sau id-ul sau catre PPU si apoi asteapta din nou primirea adresei unei noi structuri task_t
		o Daca SPU-ul primeste TASK_EXIT, termina rularea.
	-PPU:
		o codul de PPU am incercat sa il scriu cat mai compactat si modulat, pentru a nu repeta cod inutil
		o sectiunea de distribuire a task-urilor catre SPU-uri este reprezentata doar de functia distribute_tasks. Aceasta primeste un pointer la o functie ce intoarce taskurile ce trebuie trimise SPU-urilor, fara a conta tipul de task/partea problemei ce este in lucru. In momentul in care nu mai sunt taskuri in sesiunea curenta, se primeste din functie DISTRIBUTE_TASK_EXIT si se continua doar pana cand sunt primite raspunsuri de la toate SPU-urile (astfel se realizeaza sincronizarea). Practic aceasta functie este apelata la initializarea unui sir de taskuri de catre SPU-uri. Task-urile sunt obtinute prin functia data la parametru. In momentul in care toate CELL-urile au trimis raspuns la taskurile asignate lor, functia se intoarce in programul apelant.
		o task-ul construit de functia de obtinere task depinde task-ul curent si de cellID-ul SPU-ului. Pentru sincronizare intre apeluri am folosit variabile globale.
	-SPU:
		o din perspectiva SPU-ului nu conteaza ordinea task-urilor. Acesta primeste un task, analizeaza tipul acestuia si il executa.
		o la ultima parte (task-ul 6, de calcul al proiectiei), SPU-ul pune in memorie (pe aceeasi pozitie de pe care a si luat) o structura task_t ce are pe campul destination rezultatul sau. Am ales aceasta varianta pentru a evita declararea unor alte variabile in care trebuie pus rezultatul (variabile ce ar fi trebuit aliniate (size-ul unui int<16 -> complicarea alinierii la 16) ).
	- pentru a simplifica accesele la memorie prin DMA, la alocare imaginilor si a unor vectori s-a alocat putin mai mult spatiu decat este necesar (16 octeti in plus). Am ales aceasta varianta pentru ca, de exemplu daca ultimul SPU nu are de luat multiplu de 16 octeti, el poate sa ia urmatorul multiplu de 16 dupa dimensiunea task-ului sau si sa proceseze doar ce e necesar.
	
	- referitor la task-urile realizate de SPU-uri/PPU-uri:
		o PARTEA 1:
			* PPU-ul imparte dimensiunea totala a unei imagini M in bucati (strip_size) si transmite spre procesare fiecarui SPU o bucate de imagine
			* PPU-ul trimite catre SPU un vector cu adresele de inceput ale tuturor imaginilor
			* Fiecare SPU obtine din toate imaginile bucata de care se ocupa si calculeaza media, pe care o pune apoi in memoria principal
			* Dimensiunile bucatilor pe care le proceseaza se calculeaza astfel:
				- pentru primele SPU_THREADS-1 SPU-uri (in afara de ultimul) se trimit task-uri de dimensiune: cel mai mare multiplu de 16 mai mic decat M/nr_spu-uri
				- pentru ultimul SPU se transmite o dimensiune de procesat egala cu cat a ramas, si o dimensiune multiplu de 16 pe care acesta trebuie sa o ia din memoria principala. Practic el va lua putin mai mult din mem. principala, dar v-a procesa exact cat este necesar
		o PARTEA 2:
			* PPU-ul "trimite" catre fiecare SPU cate un task ce contine o imagine si vectorul medie calculat anterior
			* SPU-ul calculeaza produsul dintre vectorul imagine si vectorul medie si rezulta o matrice de MxM, pe care o pune in memoria principala prin accese multiple
			* PPU-ul "trimite" catre fiecare SPU task-uri de adunare a fasiilor unor matrice.
			* Fiecare SPU primeste un vector de adrese ale unor matrice, iau prin accese multiple bucata asignata lor din fiecare matrice si le aduna. In final trimit rezultatul inapoi in memoria principala. In cazul curent fiecare task are dimensiunea unei linii. Practic se ia aceeasi linie din mai multe matrice si se aduna.
		o PARTEA 3:
			* Se aduna matricele SW1 si SW2 generate la pasul anterior, folosind acelasi task de adunare de matrici ca in partea a doua.
		o PARTEA 4:
			* Se foloseste metoda de inversare din arhiva temei
		o PARTEA 5:
			* Se inmulteste matricea inversa de la pasul anterior cu vectorul medie. 
			* Task-ul in acest caz pentru un SPU este inmultirea unei linii din matricea SWinv cu vectorul medie, rezultand o singura valoare. 
			* Practic fiecare SPU ia o linie din matrice si vectorul dat, realizeaza inmultirea si trimite rezultatul final inapoi in memoria principala.
		o PARTEA 6:
			* Task-ul in acest caz este realizarea proiectiei: inmultierea vectorului obtinut mai sus cu un vector imagine.
			* Practic fiecare SPU ia vectorul W (care e implicit translatat) si un vector imagine (x), realizeaza inmultirea si trimite rezultatul final in memoria principala.
		o PARTEA 7:
			* Este realizata de PPU si consta in calculul mediei si al sd-ului.
		o CLASIFICARE:
			* Clasificarea este realizata de PPU, calculul proiectiei fiind realizat de SPU-uri (analog punctului 6 de mai sus).
			
4. Observatii importante
	* Tema a fost testata de multiple ori pe sistem-ul CELL, rezultatele fiind corecte de fiecare data. Uneori insa, datorita incarcarii excesive a CELL-ului, durata era foarte mare (in special in sectiunea de inversare).
	* Am folosit DOUBLE-BUFFERING in cadrul mai multor task-uri, unde era posibil si rentabil (in primele functii implementate din tema4_spu). De asemenea, am utilizat operatii cu VECTORI in zonele in care acestea erau posibile. Am intampinat in anumite zone probleme datorita faptului ca aveam de facut operatii intre date de tip pixel_t si date de tip float, pe care le-am rezolvat fie prin copii rapide fie prin evitarea folosirii operatiilor cu vectori (de exemplul task-ul de proiectie, unde nu am mai folosit operatii cu vectori).
	* Pentru task-ul din partea 5 (inmultirea unei linii din matrice cu un vector) am folosit SOFTWARE MANAGED CACHE. Aici nu am apucat sa fac o testare extrem de riguroasa (decat cateva rulari) datorita incarcarii excesive a CELL-ului si duratei foarte mari de rulare. Totusi rezultatele au fost corecte in toate aceste teste.
	* Pentru acelasi task anterior, eu am realizat si o implementare folosind transfer DMA + operatii cu vectori, varianta care este functionala, dar comentata.
  
